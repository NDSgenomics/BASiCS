# Remove functions that are not necessary anymore

#########################################################################
# Methods for BASiCS_Chain objects

#' @name BASiCS_Chain-methods
#' @aliases show,BASiCS_Chain-method
#'
#' @title 'show' method for BASiCS_Chain objects
#'
#' @description 'show' method for \code{\linkS4class{BASiCS_Chain}} objects.
#'
#' @param object A \code{\linkS4class{BASiCS_Chain}} object.
#'
#' @return Prints a summary of the properties of \code{object}.
#'
#' @examples
#'
#' Data <- makeExampleBASiCS_Data()
#' Chain <- BASiCS_MCMC(Data, N = 50, Thin = 2, Burn = 2, Regression = FALSE)
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#'
#' @rdname BASiCS_Chain-methods
setMethod("show",
          signature = "BASiCS_Chain",
          definition = function(object)
          {
            N <- nrow(object@parameters$mu)
            q.bio <- ncol(object@parameters$delta)
            n <- ncol(object@parameters$phi)
            nBatch <- ncol(object@parameters$theta)
            cat("An object of class ", class(object), "\n",
                " ", N, " MCMC samples.\n", sep = "")
            if (!("parameters" %in% methods::slotNames(object))) {
              cat("'BASiCS_Chain' object was generated by an old version of BASiCS")
            }
            else {
              N <- nrow(object@parameters$mu)
              q.bio <- ncol(object@parameters$delta)
              n <- ncol(object@parameters$phi)
              nBatch <- ncol(object@parameters$theta)
              cat("An object of class ", class(object), "\n",
                  " ", N, " MCMC samples.\n", sep = "")
              if (nBatch > 1) {
                cat(" Dataset contains ", q.bio, " biological genes and ",
                    n, " cells (", nBatch, " batches). \n", sep = "")
              }
              else {
                cat(" Dataset contains ", q.bio, " biological genes and ",
                    n, " cells (1 batch). \n", sep = "")
              }
              ChainVersion <- object@.__classVersion__$BASiCS_Chain
              ChainVersion <- paste0(ChainVersion[1], ".",
                                     ChainVersion[2], ".",
                                     ChainVersion[3])
              cat(" Object stored using BASiCS version: ", ChainVersion, "\n",
                  "Parameters: ", names(object@parameters), "\n")
            }
          })

#' @name BASiCS_Chain-methods
#' @aliases updateObject,BASiCS_Chain-method
#'
#' @title 'updateObject' method for BASiCS_Chain objects
#'
#' @description 'updateObject' method for \code{\linkS4class{BASiCS_Chain}}
#' objects. It is used to convert outdated \code{\linkS4class{BASiCS_Chain}}
#' objects into a version that is compatible with the Bioconductor release
#' of BASiCS. Do not use this method is \code{\linkS4class{BASiCS_Chain}}
#' already contains a \code{parameters} slot.
#'
#' @param ... Additional arguments of \code{\link[BiocGenerics]{updateObject}}
#' generic method. Not used within BASiCS.
#' @param verbose Additional argument of \code{\link[BiocGenerics]{updateObject}}
#' generic method. Not used within BASiCS.
#'
#' @return Returns an updated \code{\linkS4class{BASiCS_Chain}} object that
#' contains all model parameters in a single slot object (list).
#'
#' @examples
#'
#' # Not run
#' # New_Chain <- updateObject(Old_Chain)
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' @author Nils Eling \email{eling@@ebi.ac.uk}
#'
#' @rdname BASiCS_Chain-methods
setMethod("updateObject",
          signature = "BASiCS_Chain",
          definition = function(object, ..., verbose = FALSE)
          {
            if (is.null(object@mu)) {
              stop("Object was not created by an older version of BASiCS. \n")
            }

            New_Chain <- newBASiCS_Chain(parameters = list(
                                         mu = object@mu,
                                         delta = object@delta,
                                         phi = object@phi,
                                         s = object@s,
                                         nu = object@nu,
                                         theta = object@theta))

            return(New_Chain)
          })

#' @name Summary
#' @aliases Summary Summary,BASiCS_Chain-method
#'
#' @docType methods
#' @rdname Summary-BASiCS_Chain-method
#'
#' @title 'Summary' method for BASiCS_Chain objects
#'
#' @description For each of the BASiCS parameters (see Vallejos et al 2015),
#' \code{Summary} returns the corresponding postior medians and limits of
#' the high posterior density interval (probabilty equal to \code{prob})
#'
#' @param x A \code{\linkS4class{BASiCS_Chain}} object.
#' @param prob \code{prob} argument for \code{\link[coda]{HPDinterval}} function.
#'
#' @return An object of class \code{\linkS4class{BASiCS_Summary}}.
#'
#' @examples
#'
#' help(BASiCS_MCMC)
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' @author Nils Eling \email{eling@@ebi.ac.uk}
#' @export
setMethod("Summary",
          signature = "BASiCS_Chain",
          definition = function(x, prob = 0.95) {

  out <- lapply(x@parameters,
    function(n) {
      HPD <- matrix(data = NA, ncol = 3, nrow = ncol(n),
                    dimnames = list(colnames(n), c("median", "lower", "upper")))
      HPD[,1] <- colMedians(n)
      HPD[!is.na(HPD[,1]),2:3] <- coda::HPDinterval(coda::mcmc(n[,!is.na(HPD[,1])]),
                                                    prob=prob)
      HPD
  })

  if ("RefFreq" %in% names(out)) {
    out$RefFreq <- NULL
  }

  new("BASiCS_Summary", parameters = out)
})

#' @name subset
#' @aliases subset subset,BASiCS_Chain-method
#'
#' @docType methods
#' @rdname subset-BASiCS_Chain-method
#'
#' @title A 'subset' method for `BASiCS_Chain`` objects
#'
#' @description This can be used to extract a subset of a `BASiCS_Chain` object.
#' The subset can contain specific genes, cells or MCMC iterations
#'
#' @param x A \code{\linkS4class{BASiCS_Chain}} object.
#' @param Genes A vector of characters indicating what genes will be extracted.
#' @param Cells A vector of characters indicating what cells will be extrated.
#' @param Iterations Numeric vector of positive integers indicating which MCMC
#' iterations will be extracted. The maximum value in \code{Iterations} must be
#' less or equal than the total number of iterations contained in the original
#' \code{\linkS4class{BASiCS_Chain}} object.
#'
#' @return An object of class \code{\linkS4class{BASiCS_Chain}}.
#'
#' @examples
#'
#' help(BASiCS_MCMC)
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#'
setMethod("subset",
          signature = "BASiCS_Chain",
          definition = function(x, Genes = NULL,
                                Cells = NULL, Iterations = NULL){

            N <- nrow(displayChainBASiCS(x, Param = "mu"))
            q <- ncol(displayChainBASiCS(x, Param = "mu"))
            n <- ncol(displayChainBASiCS(x, Param = "nu"))
            GeneName <- colnames(displayChainBASiCS(x, Param = "mu"))
            CellName <- colnames(displayChainBASiCS(x, Param = "nu"))

            # Checking for valid arguments + assigning default values
            if (is.null(Iterations)) {
              Iterations <- seq_len(N)
            }
            else {
              stopifnot(all(Iterations == floor(Iterations)))
              stopifnot(min(Iterations) >= 1, max(Iterations) <= N )
            }
            if (is.null(Genes)) {
              Genes <- GeneName
            }
            else {
              if (sum(!(Genes %in% GeneName)) > 0) {
                stop("Some elements of 'Genes' are not present in the data")
              }
            }
            if (is.null(Cells)) {
              Cells <- CellName
            }
            else {
              if (sum(!(Cells %in% CellName)) > 0) {
                stop("Some elements of 'Cells' are not present in the data")
              }
            }

            SelGenes <- GeneName %in% Genes
            SelCells <- CellName %in% Cells
            Params <- names(x@parameters)

            out <- list()
            for(p in seq_len(length(Params))) {
              if (Params[p] %in% c("theta", "beta", "sigma2")) {
                out[[p]] <- get(Params[p], x@parameters)[Iterations, , drop = FALSE]
              }
              else {
                if (Params[p] %in% c("mu", "delta", "epsilon")) {
                  Sel <- SelGenes
                }
                if (Params[p] %in% c("phi", "s", "nu")) {
                  Sel <- SelCells
                }
                out[[p]] <- get(Params[p], x@parameters)[Iterations, Sel]
              }
            }
            names(out) <- Params

            # Transform into BASiCS_Chain class object
            out1 <- newBASiCS_Chain(parameters = out)
            out1@.__classVersion__$BASiCS_Chain <- x@.__classVersion__$BASiCS_Chain

            return(out1)
          })


#' @name colnames
#' @aliases colnames colnames,BASiCS_Chain-method
#'
#' @docType methods
#' @rdname colnames-BASiCS_Chain-method
#'
#' @title 'colnames' method for BASiCS_Chain objects
#'
#' @description Returns the labels of cell-specific BASiCS parameters
#'
#' @param x A \code{\linkS4class{BASiCS_Chain}} object.
#'
#' @return An vector of labels
#'
#' @examples
#'
#' help(BASiCS_MCMC)
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#'
setMethod("colnames",
          signature = "BASiCS_Chain",
          definition = function(x) colnames(x@parameters$s))

#' @name rownames
#' @aliases rownames rownames,BASiCS_Chain-method
#'
#' @docType methods
#' @rdname rownames-BASiCS_Chain-method
#'
#' @title 'rownames' method for BASiCS_Chain objects
#'
#' @description Returns the labels of gene-specific BASiCS parameters
#'
#' @param x A \code{\linkS4class{BASiCS_Chain}} object.
#'
#' @return An vector of labels
#'
#' @examples
#'
#' help(BASiCS_MCMC)
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#'
setMethod("rownames",
          signature = "BASiCS_Chain",
          definition = function(x) return(colnames(x@parameters$mu)))

#' @name plot-BASiCS_Chain-method
#' @aliases plot plot,BASiCS_Chain-method plot,BASiCS_Chain,ANY-method
#'
#' @docType methods
#' @rdname plot-BASiCS_Chain-method
#'
#' @title 'plot' method for BASiCS_Chain objects
#'
#' @description 'plot' method for \code{\linkS4class{BASiCS_Chain}} objects
#'
#' @param x A \code{\linkS4class{BASiCS_Chain}} object.
#' @param Param Name of the slot to be used for the plot.
#' Possible values: \code{'mu'}, \code{'delta'},
#' \code{'phi'}, \code{'s'}, \code{'nu'}, \code{'theta'},
#' \code{'beta'}, \code{'sigma2'} and \code{'epsilon'}.
#' @param Gene Specifies which gene is requested.
#' Required only if \code{Param = 'mu'} or \code{'delta'}
#' @param Cell Specifies which cell is requested.
#' Required only if \code{Param = 'phi', 's'} or \code{'nu'}
#' @param Batch Specifies which batch is requested.
#' Required only if \code{Param = 'theta'}
#' @param RegressionTerm Specifies which regression coefficient is requested.
#' Required only if \code{Param = 'beta'}
#' @param ylab As in \code{\link[graphics]{par}}.
#' @param xlab As in \code{\link[graphics]{par}}.
#' @param ... Other graphical parameters (see \code{\link[graphics]{par}}).
#'
#' @return A plot object
#'
#' @examples
#'
#' # See
#' help(BASiCS_MCMC)
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' @author Nils Eling \email{eling@@ebi.ac.uk}
#'
#' @importFrom ggExtra ggMarginal 
#' @importFrom cowplot plot_grid
setMethod("plot",
          signature = "BASiCS_Chain",
          definition = function(x,
                                Param = "mu",
                                Gene = NULL, Cell = NULL, Batch = 1,
                                RegressionTerm = NULL,
                                ylab = "", xlab = "", ...)
          {
            if (Param %in% c("mu", "delta", "epsilon") & is.null(Gene)) {
              stop("'Gene' value is required")
            }
            if (Param %in% c("phi", "s", "nu") & is.null(Cell)) {
              stop("'Cell' value is required")
            }
            if (Param %in% c("theta") & is.null(Batch)) {
              stop("'Batch' value is required")
            }
            if (Param %in% c("beta") & is.null(RegressionTerm)) {
              stop("'RegressionTerm' value is required")
            }

            if (Param %in% HiddenGeneParams()) {
              Column <- Gene
            } else if (Param %in% HiddenCellParams()) {
              Column <- Cell
            } else if (Param == "theta") {
              Column <- Batch
            } else if (Param == "beta") {
              Column <- RegressionTerm
            }
            if (xlab == "") {
              xlab <- "Iteration"
            }
            if (ylab == "") {
              ylab <- bquote(.(Param)[.(Column)])
            }
            
            DF1 <- data.frame("Iteration" = seq_len(nrow(x@parameters[[Param]])),
                              "Draws" = x@parameters[[Param]][, Column])
            # Code inspired by https://stackoverflow.com/questions/17788859/acf-plot-with-ggplot2-setting-width-of-geom-bar
            MyAcf <- acf(x@parameters[[Param]][,Column], plot = FALSE)
            DF2 <- with(MyAcf, data.frame(lag, acf))
            
            # Traceplot
            p1 <- ggplot2::ggplot(DF1) + 
              ggplot2::geom_point(aes_string(x = "Iteration", y = "Draws"),
                                  col = grDevices::adjustcolor("white", 
                                                               alpha.f = 0) ) + 
              ggplot2::geom_line(aes_string(x= "Iteration", y = "Draws")) + 
              ggplot2::xlab("Iteration") + ggplot2::ylab("Parameter value") + 
              ggplot2::theme_classic() + 
              ggplot2::ggtitle(colnames(x@parameters[[Param]])[Column]) 
            p1 <- ggExtra::ggMarginal(p1, type = "histogram", margins = "y")
              
            p2 <- ggplot2::ggplot(DF2, aes_string(x = "lag", y = "acf")) + 
              ggplot2::theme_classic() + 
              ggplot2::geom_hline(aes(yintercept = 0)) + 
              ggplot2::geom_segment(mapping = aes_string(xend = "lag", yend = 0)) +
              ggplot2::ggtitle(colnames(x@parameters[[Param]])[Column])
            
            cowplot::plot_grid(p1, p2)
            
          })


getParam <- function(object, Param = "mu") {
  if (is.null(Param) || 
      is.na(Param) || 
      length(Param) > 1 ||
      !(Param %in% names(object@parameters))) {
    stop("'Param' argument is invalid")
  }
  object@parameters[[Param]]
}


#' @name displayChainBASiCS-BASiCS_Chain-method
#' @aliases displayChainBASiCS displayChainBASiCS,BASiCS_Chain-method
#'
#' @docType methods
#' @rdname displayChainBASiCS-BASiCS_Chain-method
#'
#' @title Accessors for the slots of a BASiCS_Chain object
#'
#' @description Accessors for the slots of a \code{\linkS4class{BASiCS_Chain}}
#'
#' @param object an object of class \code{\linkS4class{BASiCS_Chain}}
#' @param Param Name of the slot to be used for the accessed.
#' Possible values: \code{'mu'}, \code{'delta'}, \code{'phi'},
#' \code{'s'}, \code{'nu'}, \code{'theta'}, \code{'beta'},
#' \code{'sigma2'} and \code{'epsilon'}.
#'
#' @return The requested slot of a \code{\linkS4class{BASiCS_Chain}} object
#'
#' @examples
#'
#' # See
#' help(BASiCS_MCMC)
#'
#' @seealso \code{\linkS4class{BASiCS_Chain}}
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' @author Nils Eling \email{eling@@ebi.ac.uk}
#'
#' @export
setMethod("displayChainBASiCS",
          signature = "BASiCS_Chain",
          definition = getParam)

#' @name BASiCS_showFit-BASiCS_Chain-method
#' @aliases BASiCS_showFit BASiCS_showFit,BASiCS_Chain-method
#'
#' @docType methods
#' @rdname BASiCS_showFit-BASiCS_Chain-method
#'
#' @title Plotting the trend after Bayesian regression
#'
#' @description Plotting the trend after Bayesian regression using a
#' \code{\linkS4class{BASiCS_Chain}} object
#'
#' @param object an object of class \code{\linkS4class{BASiCS_Chain}}
#' @param xlab As in \code{\link[graphics]{par}}.
#' @param ylab As in \code{\link[graphics]{par}}.
#' @param pch As in \code{\link[graphics]{par}}. Default value \code{pch = 16}.
#' @param smooth Logical to indicate wether the smoothScatter function is used
#' to plot the scatter plot. Default value \code{smooth = TRUE}. 
#' @param variance Variance used to build GRBFs for regression. Default value
#' \code{variance = 1.2} 
#' @param colour colour used to denote genes within the scatterplot. Only used 
#' when \code{smooth = TRUE}. Default value 
#' \code{colour = "dark blue"}. 
#' @param markExcludedGenes Whether or not lowly expressed genes that were
#' excluded from the regression fit are included in the scatterplot.
#' Default value \code{markExcludedGenes = TRUE}.
#' @param GenesSel Vector of gene names to be highlighted in the scatterplot.
#' Only used when \code{smooth = TRUE}. Default value \code{GenesSel = NULL}.
#' @param colourGenesSel colour used to denote the genes listed in 
#' \code{GenesSel} within the scatterplot. Default value 
#' \code{colourGenesSel = "dark red"}.
#' @param ... Additional parameters for plotting.
#'
#' @examples
#' data(ChainRNAReg)
#' BASiCS_showFit(ChainRNAReg)
#'
#' @return A plot object
#'
#' @author Nils Eling \email{eling@@ebi.ac.uk}
#' @author Catalina Vallejos \email{cnvallej@@uc.cl}
#'
#' @references
#' Eling et al (2018). Cell Systems
#' https://doi.org/10.1016/j.cels.2018.06.011
#' @export
setMethod("BASiCS_showFit",
          signature = "BASiCS_Chain",
          definition = function(object,
                                xlab = "log(mu)",
                                ylab = "log(delta)",
                                pch = 16,
                                smooth = TRUE,
                                variance = 1.2,
                                colour = "dark blue",
                                markExcludedGenes = TRUE,
                                GenesSel = NULL,
                                colourGenesSel = "dark red",
                                ...){

            if (!("beta" %in% names(object@parameters))) {
              stop("'beta' is missing. Regression was not performed.")
            }


            m <- log(object@parameters$mu[1,])
            grid.mu <- seq(round(min(m), digits = 2),
                           round(max(m), digits = 2), length.out = 1000)

            # Create design matrix across the grid
            n <- ncol(object@parameters$beta)
            range <- diff(range(grid.mu))
            myu <- seq(min(grid.mu), by = range/(n-3), length.out = n-2)
            h <- diff(myu)*variance

            B <- matrix(1,length(grid.mu),n)
            B[,2] <- grid.mu
            for (j in seq_len(n-2)) {
              B[,j+2] = exp(-0.5 * (grid.mu - myu[j])^2 / (h[1]^2))
            }

            # Calculate yhat = X*beta
            yhat <- apply(object@parameters$beta, 1, function(n) B%*%n)
            yhat.HPD <- coda::HPDinterval(coda::mcmc(t(yhat)), 0.95)

            df <- data.frame(mu = log(colMedians(object@parameters$mu)),
                             delta = log(colMedians(object@parameters$delta)),
                             included = !is.na(object@parameters$epsilon[1,]))
            rownames(df) <- colnames(object@parameters$mu)

            df2 <- data.frame(mu2 = grid.mu,
                              yhat = rowMedians(yhat),
                              yhat.upper = yhat.HPD[,2],
                              yhat.lower = yhat.HPD[,1])
            plot.out <- ggplot(df[df$included,],
                               aes_string(x = "mu", y = "delta")) +
              xlab(xlab) + ylab(ylab) +
              theme_minimal(base_size = 15)
            if(markExcludedGenes == TRUE) {
              plot.out <- plot.out + 
              geom_point(data = df[!df$included, ],
                         shape = pch,
                         colour = "purple",
                         alpha = 0.3)
            }

            if (smooth) {
              plot.out <- plot.out +
                geom_hex(bins = 100) +
                scale_fill_gradientn(name = "",
                                     colours = colorRampPalette(
                                      c("dark blue", "yellow", "dark red"))(100),
                                     guide = FALSE)
            }
            else {
              plot.out <- plot.out +
                geom_point(shape = pch,
                           colour = colour)
            }
            if(!is.null(GenesSel)) {
              if(sum(GenesSel %in% rownames(df)) != length(GenesSel)) {
                stop("Some elements of `GenesSel` are not found in the data.")
              }
              plot.out <- plot.out +
                geom_point(data = df[rownames(df) %in% GenesSel,],
                           shape = pch,
                           colour = colourGenesSel)
            }
            
            plot.out <- plot.out + 
              geom_line(data = df2,
                        inherit.aes = FALSE,
                        mapping = aes_string(x = "mu2", y = "yhat"),
                        colour = "dark red") +
              geom_ribbon(data = df2,
                          inherit.aes = FALSE,
                          mapping = aes_string(x = "mu2",
                                               ymin = "yhat.lower",
                                               ymax = "yhat.upper"),
                          alpha = 0.5)
              
            return(plot.out)
          })

#########################################################################
# Methods for BASiCS_Summary objects

#' @name BASiCS_Summary-methods
#' @aliases show,BASiCS_Summary-method
#'
#' @title 'show' method for BASiCS_Summary objects
#'
#' @description 'show' method for \code{\linkS4class{BASiCS_Summary}} objects.
#'
#' @param object A \code{\linkS4class{BASiCS_Summary}} object.
#'
#' @return Prints a summary of the properties of \code{object}.
#'
#' @examples
#'
#' # See
#' help(BASiCS_MCMC)
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' @author Nils Eling \email{eling@@ebi.ac.uk}
#'
#' @rdname BASiCS_Summary-methods
setMethod("show",
          signature = "BASiCS_Summary",
          definition = function(object)
          {
            q <- nrow(object@parameters$mu)
            q.bio <- nrow(object@parameters$delta)
            n <- nrow(object@parameters$phi)
            nBatch <- nrow(object@parameters$theta)
            cat("An object of class ", class(object), "\n",
                " Contains posterior medians and the limits of the \n",
                " HPD interval for all BASiCS model parameters.\n")

            if (nBatch > 1) {
              cat("  Dataset contains ", q, " genes ",
                  "(", q.bio, " biological and ", q-q.bio, " technical) \n",
                  "  and ", n, " cells (", nBatch, " batches). \n", sep = "")
            }
            else {
              cat("  Dataset contains ", q, " genes ",
                  "(", q.bio, " biological and ", q-q.bio, " technical) \n",
                  "  and ", n, " cells (1 batch). \n", sep = "")
            }
            ChainVersion <- object@.__classVersion__$BASiCS_Summary
            ChainVersion <- paste0(ChainVersion[1], ".",
                                   ChainVersion[2], ".",
                                   ChainVersion[3])
            cat("  Object stored using BASiCS version: ", ChainVersion, "\n",
                " Parameters: ", names(object@parameters), "\n")
          })




#' @name plot-BASiCS_Summary-method
#' @aliases plot,BASiCS_Summary-method, plot,BASiCS_Summary,ANY-method
#'
#' @docType methods
#' @rdname plot-BASiCS_Summary-method
#'
#' @title 'plot' method for BASiCS_Summary objects
#'
#' @description 'plot' method for \code{\linkS4class{BASiCS_Summary}} objects
#'
#' @param x A \code{\linkS4class{BASiCS_Summary}} object.
#' @param Param Name of the slot to be used for the plot.
#' Possible values: \code{'mu'}, \code{'delta'},
#' \code{'phi'}, \code{'s'}, \code{'nu'}, \code{'theta'}, \code{'beta'},
#' \code{'sigma2'} and \code{'epsilon'}.
#' @param Param2 Name of the second slot to be used for the plot.
#' Possible values: \code{'mu'}, \code{'delta'}, \code{'epsilon'},
#' \code{'phi'}, \code{'s'} and \code{'nu'}
#' (combinations between gene-specific and
#' cell-specific parameters are not admitted).
#' @param Genes Specifies which genes are requested.
#' Required only if \code{Param = 'mu'}, \code{'delta'} or \code{'epsilon'}.
#' @param Cells Specifies which cells are requested.
#' Required only if \code{Param = 'phi', 's'} or \code{'nu'}
#' @param Batches Specifies which batches are requested.
#' Required only if \code{Param = 'theta'}
#' @param RegressionTerms Specifies which regression coefficients are requested.
#' Required only if \code{Param = 'beta'}
#'
#' @param xlab As in \code{\link[graphics]{par}}.
#' @param ylab As in \code{\link[graphics]{par}}.
#' @param xlim As in \code{\link[graphics]{par}}.
#' @param ylim As in \code{\link[graphics]{par}}.
#' @param pch As in \code{\link[graphics]{par}}.
#' @param col As in \code{\link[graphics]{par}}.
#' @param bty As in \code{\link[graphics]{par}}.
#' @param SmoothPlot Logical parameter. If \code{TRUE},
#' transparency will be added to the color of the dots.
#' @param ... Other graphical parameters (see \code{\link[graphics]{par}}).
#'
#' @return A plot object
#'
#' @examples
#'
#' # See
#' help(BASiCS_MCMC)
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' @author Nils Eling \email{eling@@ebi.ac.uk}
#'
#' @export
setMethod("plot",
          signature = "BASiCS_Summary",
          definition = function(x, Param = "mu", Param2 = NULL,
                                Genes = NULL, Cells = NULL, Batches = NULL,
                                RegressionTerms = NULL,
                                xlab = "", ylab = "", xlim = "", ylim = NULL,
                                pch = 16, col = "blue", bty = "n",
                                SmoothPlot = TRUE, ...)
          {

            if (!(Param %in% names(x@parameters))) {
              stop("'Param' argument is invalid")
            }

            q <- nrow(x@parameters$mu)
            q.bio <- nrow(x@parameters$delta)
            n <- nrow(x@parameters$s)
            nBatch <- nrow(x@parameters$theta)

            if (is.null(Genes)) {
              Genes <- seq_len(q.bio)
            }
            if (is.null(Cells)) {
              Cells <- seq_len(n)
            }
            if (is.null(Batches)) {
              Batches <- seq_len(nBatch)
            }

            if("beta" %in% names(x@parameters)) {
              k <- nrow(x@parameters$beta)
              if (is.null(RegressionTerms)) {
                RegressionTerms <- seq_len(k)
              }
            }

            if (is.null(Param2)) {
              object <- x@parameters[[Param]]

              if (Param %in% HiddenGeneParams()) {
                Columns <- Genes
                ylabInd <- "i"
                if (xlab == "") {
                  xlab <- "Gene"
                }
              } else if (Param %in% HiddenCellParams()) {
                Columns <- Cells
                ylabInd <- "j"
                if (xlab == "") {
                  xlab <- "Cell"
                }
              } else if (Param == "theta") {
                Columns <- Batches
                ylabInd <- "b"
                if (xlab == "") {
                  xlab <- "Batch"
                }
              } else if (Param == "beta") {
                Columns <- RegressionTerms
                ylabInd <- "k"
                if (xlab == "") {
                  xlab <- "Regression term"
                }
              } else if (Param == "sigma2") {
                object <- x@parameters$sigma2
                Columns <- 1
                ylabInd <- "i"
                if (xlab == "") {
                  xlab <- "Gene"
                }
              }

              if (ylab == "") {
                ylab <- bquote(.(Param)[.(ylabInd)])
              }
              if (is.null(ylim)) {
                ylim = c(min(object[Columns, 2]), max(object[Columns, 3]))
              }

              # Point estimates
              plot(x = Columns,
                   y = object[Columns, 1],
                   xlab = xlab,
                   ylab = ylab,
                   ylim = ylim,
                   pch = pch,
                   col = col,
                   bty = bty,
                   ...
              )

              # Add HPD interval
              for (Column in Columns) {
                BarLength <- ifelse(length(Columns) <= 10,
                                    0.1,
                                    2 / length(Columns))

                segments(x0 = Column,
                         y0 = object[Column, 2],
                         y1 = object[Column, 3],
                         col = col)
                segments(x0 = Column - BarLength,
                         y0 = object[Column, 2],
                         x1 = Column + BarLength,
                         col = col)
                segments(x0 = Column - BarLength,
                         y0 = object[Column, 3],
                         x1 = Column + BarLength,
                         col = col)
              }

          } else {
            if (!Param2 %in% names(x@parameters)) {
              stop("'Param2' is not a parameter in this BASiCS_Summary object")
            }
            HiddenCheckValidCombination(Param, Param2)
            if (SmoothPlot) {
              col <- grDevices::rgb(grDevices::col2rgb(col)[1],
                                    grDevices::col2rgb(col)[2],
                                    grDevices::col2rgb(col)[3],
                                    50,
                                    maxColorValue = 255)
            }
            if (Param %in% HiddenGeneParams()) {
              Columns <- Genes
              ylabInd <- "i"
            }
            if (Param %in% HiddenCellParams()) {
              Columns <- Cells
              ylabInd <- "j"
            }
            plot(
              x@parameters[[Param]][Columns, 1],
              x@parameters[[Param2]][Columns, 1],
              xlab = bquote(.(Param)[.(ylabInd)]),
              ylab = bquote(.(Param2)[.(ylabInd)]),
              xlim = c(
                min(x@parameters[[Param]][Columns, 1]),
                max(x@parameters[[Param]][Columns, 1])
              ),
              ylim = c(
                min(x@parameters[[Param2]][Columns, 1]),
                max(x@parameters[[Param2]][Columns, 1])
              ),
              pch = pch,
              col = col,
              bty = bty,
              ...
            )
          }
        })


#' @name displaySummaryBASiCS-BASiCS_Summary-method
#' @aliases displaySummaryBASiCS displaySummaryBASiCS,BASiCS_Summary-method
#'
#' @docType methods
#' @rdname displaySummaryBASiCS-BASiCS_Summary-method
#'
#' @title Accessors for the slots of a \code{\linkS4class{BASiCS_Summary}} object
#'
#' @description Accessors for the slots of a \code{\linkS4class{BASiCS_Summary}}
#' object
#'
#' @param object an object of class \code{\linkS4class{BASiCS_Summary}}
#' @param Param Name of the slot to be used for the accessed.
#' Possible values: \code{'mu'}, \code{'delta'}, \code{'phi'},
#' \code{'s'}, \code{'nu'}, \code{'theta'}, \code{'beta'},
#' \code{'sigma2'} and \code{'epsilon'}.
#'
#' @return The requested slot of a \code{\linkS4class{BASiCS_Summary}} object
#'
#' @examples
#'
#' # See
#' help(BASiCS_MCMC)
#'
#' @seealso \code{\linkS4class{BASiCS_Summary}}
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' @author Nils Eling \email{eling@@ebi.ac.uk}
#'
#' @export
setMethod("displaySummaryBASiCS",
          signature = "BASiCS_Summary",
          definition = getParam)







#' @name Plots of diagnostic measure for MCMC parameters
#' @aliases BASiCS_diagPlot BASiCS_diagPlot-method
#'
#' @docType methods
#'
#' @title Create diagnostic plots of MCMC parameters
#'
#' @description Plot parameter values and effective sample size.
#' See \link[coda]{effectiveSize}
#' for more details on this diagnostic measure.
#'
#' @param object an object of class \code{\linkS4class{BASiCS_Summary}}
#' @param Param Optional name of a chain parameter to restrict the histogram;
#' if not supplied, all parameters will be assessed.
#' Possible values: \code{'mu'}, \code{'delta'}, \code{'phi'},
#' \code{'s'}, \code{'nu'}, \code{'theta'}, \code{'beta'},
#' \code{'sigma2'} and \code{'epsilon'}.
#' @param x,y Optional MCMC parameter values to be plotted on the x or y axis, 
#' respectively. If neither is supplied, Param will be plotted on the x axis
#' and \code{coda::effectiveSize(Param)} will be plotted on the y axis as
#' a density plot.
#' @param LogX,LogY A boolean value indicating whether to use a log10
#' transformation for the x or y axis, respectively.
#' 
#' @return A ggplot object.
#'
#' @examples
#'
#' # See
#' help(BASiCS_MCMC)
#'
#' @seealso \code{\linkS4class{BASiCS_Chain}}
#'
#' @author Alan O'Callaghan \email{a.b.ocallaghan@sms.ed.ac.uk}
#' 
#' @importFrom viridis scale_color_viridis
#' @importFrom viridis scale_fill_viridis
#'
#' @export
setMethod("BASiCS_diagPlot",
          signature = "BASiCS_Chain",
          definition = function(object, 
                                Param = "mu", 
                                x = NULL, 
                                y = NULL,
                                LogX = isTRUE(x %in% c("mu", "delta")),
                                LogY = isTRUE(y %in% c("mu", "delta"))) {

            if (!is.null(x) || !is.null(y)) {
              if (!is.null(x) && is.null(y)) {
                stop("Must specify both x and y or neither!")
              }
            } else {
              LogX <- Param %in% c("mu", "delta")
            }
            Measure <- "effectiveSize"
            HiddenCheckValidCombination(x, y, Param)
            metric <- HiddenGetMeasure(object, Param, Measure)
            sX <- if (LogX) scale_x_log10() else scale_x_continuous()
            sY <- if (LogY) scale_y_log10() else scale_y_continuous()

            if (!is.null(x)) {
              xMat <- getParam(object, x)
              yMat <- getParam(object, y)
              df <- data.frame(
                x = colMedians(xMat),
                y = colMedians(yMat),
                metric = metric
              )
              ggplot(df, aes(x = x, y = y, color = metric)) + 
                geom_point(alpha = 0.5, shape = 16) +
                viridis::scale_color_viridis(name = HiddenScaleName(Measure, Param)) +
                sX + sY +
                labs(x = x,
                     y = y)              
            } else {
              xMat <- getParam(object, Param)
              df <- data.frame(
                x = colMedians(xMat),
                y = metric
              )
              ggplot(df, aes(x = x, y = metric)) + 
                geom_hex(aes_string(fill = "..density..")) +
                viridis::scale_fill_viridis(name = "Density") +
                sX + sY +
                labs(x = Param,
                     y = HiddenScaleName(Measure))
            }
          }
)



HiddenScaleName <- function(Measure = c("effectiveSize",
                                  "geweke.diag"),
                      Param = NULL) {
  Measure <- match.arg(Measure)
  measure_name <- switch(Measure, 
    effectiveSize = "Effective sample size",
    geweke.diag = "Geweke diagnostic"
  )
  if (!is.null(Param)) {
    measure_name <- paste0(measure_name, ": ", Param)
  }
  measure_name
}

#' @name Histograms of diagnostic measure for MCMC parameters
#' @aliases BASiCS_diagHist BASiCS_diagHist-method
#'
#' @docType methods
#'
#' @title Create diagnostic plots of MCMC parameters
#'
#' @description Plot a histogram of effective sample size or Geweke's diagnostic
#' z-statistic. See \link[coda]{effectiveSize} and \link[coda]{geweke.diag} for
#' more details.
#'
#' @param object an object of class \code{\linkS4class{BASiCS_Summary}}
#' @param Param Optional name of a chain parameter to restrict the histogram;
#' if not supplied, all parameters will be assessed.
#' Possible values: \code{'mu'}, \code{'delta'}, \code{'phi'},
#' \code{'s'}, \code{'nu'}, \code{'theta'}, \code{'beta'},
#' \code{'sigma2'} and \code{'epsilon'}.
#' @param Measure The diagnostic measure to be plotted in the histogram.
#' Possible values: \code{"effectiveSize"}, \code{"geweke.diag"}.
#'
#' @return A ggplot object.
#'
#' @examples
#'
#' # See
#' help(BASiCS_MCMC)
#'
#' @seealso \code{\linkS4class{BASiCS_Chain}}
#'
#' @author Alan O'Callaghan \email{a.b.ocallaghan@sms.ed.ac.uk}
#'
#' @export
setMethod("BASiCS_diagHist",
          signature = signature("BASiCS_Chain"),
          definition = function(object, 
                                Param = NULL) {

            Measure <- "effectiveSize"

            if (is.null(Param)) {
              metric <- lapply(names(object@parameters), function(param) {
                HiddenGetMeasure(object, param, Measure)
              })
              metric <- Reduce(c, metric)              
            } else {
              metric <- HiddenGetMeasure(object, Param, Measure)
            }
            if (length(metric) == 1) {
              stop(paste0("Cannot produce histogram of a single value (", metric, ")"))
            }
            ggplot(mapping = aes(x = metric)) + 
              geom_histogram(bins = grDevices::nclass.FD(metric)) +
              labs(x = HiddenScaleName(Measure, Param),
                   y = "Count")
            }
)


HiddenCheckValidCombination <- function(...) {
  Params <- list(...)
  if (!(all(sapply(Params, function(x) is.null(x) || x %in% HiddenGeneParams())) || 
        all(sapply(Params, function(x) is.null(x) || x  %in% HiddenCellParams())))) {
    stop(paste("Invalid combination of parameters:",
               paste(list(...), collapse = ", "), " \n"))
  } 
}

HiddenGetMeasure <- function(object, 
                       Param,
                       Measure = c("effectiveSize",
                                   "geweke.diag")) {
  Measure <- match.arg(Measure)
  MeasureFun <- match.fun(Measure)
  metric <- MeasureFun(coda::mcmc(getParam(object, Param)))
  if (Measure == "geweke.diag") {
    metric <- metric$z
  }
  metric
}

HiddenGeneParams <- function() c("mu", "delta", "epsilon")
HiddenCellParams <- function() c("s", "phi", "nu")
